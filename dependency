依赖管理

JavaScript缺失了很多计算机高级编程语言所应有的功能特性，其中一个重要的特性就是依赖管理和模块系统。和其他编程语言不同，对于很多学习JS的人来说，并不会过多关注命名空间和模块化等这些传统的重要知识点。

构建大型应用需要引入模块化，命名空间和依赖管理系统。很长时间内，前端工程师们以为只用scriopt标签就足够了，毕竟页面中实用的JS代码不涉及太多的维护和扩展。但开始编写复杂的JS应用时，就必须引入依赖管理系统。手动维护页面中的Script标签之间的依赖关系根本不可行，代会码变得混乱不堪。

依赖管理系统除了能解决实际的编程复杂度和可维护性的问题，还能解决性能方面的问题。浏览器需要为每个JS文件发起一个HTTP请求，尽管可以将这些请求放入异步队列，但大量的HTTP连接总会造成性能的下降，每个连接都包含额外的HTTP头信息、cookie，并都要做TCP的3次握手。当应用是基于SSL提供当服务话，情况会更糟。

CommonJS

当大家开始关注如何将JS应用于服务器端时，引入了很多解决依赖管理问题的建议方法。SpiderMonkey(https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey) 和Rhine(https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino) 提供了load()函数，但并没有很好的解决命名空间的问题。Node.js(http://nodejs.org)提供了require()函数，用来加载外部资源文件，Node.js自有的模块系统也使用这种方式来管理。但代码的可移植性不好。

为了让代码更具可移植性，亟需引入一个标准解决方案，让所有JS都能遵照这个标准来实现统一的模块管理系统，这样JS代码库就可以运行在所有的环境中。Kevini Dangoor按照这个思路提出了CommonJS规范。他在博客首次提出了一个公开的标准，这标准适用于JS解释器和开发者，他对此做了一个说明：
JS需要一个标准的方法来解决加载外部模块和用命名空间的方式谨慎管理模块的问题。命名空间的问题很容易解决。但并没有标准的编程模式来（一次性）解决加载模块的问题。
这不是一个技术问题，而是需要我们在一起共同讨论并达成一致————给出构建大型应用的通用方法，群策群力才能让这个标准影响范围更大、看起来更酷。

随着邮件列表(https://groups.google.com/group/commonjs)的建立，CommonJS(http://wiki.commonjs.org/wiki/CommonJS)诞生了。它包含了很多标准，包括IO接口、底层的套接字流,以及单元测试。




